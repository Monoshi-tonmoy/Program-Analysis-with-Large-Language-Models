{"idx": 0, "msg": "double aliasing", "code": "int fun1() {\n    int i;\n    char arr1[2];\n    char arr2[10];\n    /* ... */\n    for (i = 0; i != 10; ++i) {\n        ((short*)arr1)[0] = arr2[i];\n        arr1[1] = arr2[9-i];\n    }\n    return 0;\n}"}
{"idx": 1, "msg": "two types with same memory location", "code": "int fun2() {\n    int num = 10;\n    int *intptr = &num;\n    float *floatptr = (float *)&num;\n\n    *floatptr = 20.5;\n\n    printf(\"Value of num: %d\\n\", num);\n    printf(\"Value at floatptr: %f\\n\", *floatptr);\n\n    return 0;\n}"}
{"idx": 2, "msg": "Dereferencing unallocated memory", "code": "int fun3() {\n    int arr[5] = {0, 1, 2, 3, 4};\n    int *ptr = arr;\n    int value = *(ptr + 6);\n    return 0;\n}"}
{"idx": 3, "msg": "Dereferncing NULL", "code": "int fun4() {\n    int *ptr = NULL;\n    int value;\n    value = *ptr;\n    return 0;\n}"}
{"idx": 4, "msg": "Unsafe derefence of struct", "code": "struct Ex {\n    int field;\n};\n\nint fun5(struct Ex *d) {\n    int val;\n    if (d->field) \n        val = 1;\n\n    if (d->field)\n        val = 2;\n    return 0;\n}"}
{"idx": 5, "msg": "Unsafe dereference of int*", "code": "int fun6(int *d) {\n    int val = *d;\n    val += 10;\n    return val;\n}"}
{"idx": 6, "msg": "Dereferncing undefined", "code": "int fun7() {\n    int* p;\n    int n = *p1;\n    printf(\"%d\", n);\n    return 0;\n}"}
{"idx": 7, "msg": "Memory leak", "code": "int fun8() {   \n    int *ptr = (int*)malloc(sizeof(int));\n    *ptr = 15;\n    printf(\"%d\\n\", *ptr);\n    ptr = NULL;\n    return 0;\n}"}
{"idx": 8, "msg": "Freeing unallocated memory", "code": "int fun9() {\n    int *ptr;\n    *ptr = 15;\n    int temp = *ptr;\n    free(ptr);\n    return temp;\n}"}
{"idx": 9, "msg": "Multiple free", "code": "int fun10() {\n    int *ptr = (int *)malloc(sizeof(int));\n    int val = 50;\n    for(int i = 0; i < 25; i++) {\n        *ptr = val * i;\n        free(ptr);\n    }\n    return 0;\n}"}
{"idx": 10, "msg": "Double free", "code": "int send_msg(char *ptr, int len) {\n    while(i < len) {\n        buf_write_msg(ptr + i);\n        i++;\n    }\n    free(ptr);\n    return i;\n}\n\nint tx_int(char *ptr) {\n    int val = OBJ_SIZE;\n    while(val < OBJ_SIZE) {\n        send_msg(ptr, 16);\n    }\n    free(ptr);\n}"}
{"idx": 11, "msg": "Unsafe derefence", "code": "typedef struct elem_list {\n    int val;\n    struct elem_list *next;\n} Elements;\n\nint elem_member(int val, Elements *c) {\n    Elements *elem;\n    for(elem == c; c != NULL; elem = elem->next) {\n        if(elem->val == val) {\n            return 1;\n        }\n    }\n    return 0;\n}"}
{"idx": 12, "msg": "Memory leak", "code": "int bar() { int a = 12, b = 24; int *sum = (int*)malloc(sizeof(int)); *sum = a + b; printf(\"%d\\n\", *sum); printf(\"%d\\n\", *sum); return 0; }"}
{"idx": 13, "msg": "Possible integer overflow", "code": "board_square_t *make_board() {\n    #define MAX_DIM 100\n    int m,n, error;\n    board_square_t *board;\n    printf(\"Please specify the board height: \\n\");\n    error = scanf(\"%d\", &m);\n    if ( EOF == error ){\n        die(\"No integer passed: Die evil hacker!\\n\");\n    }\n    printf(\"Please specify the board width: \\n\");\n    error = scanf(\"%d\", &n);\n    if ( EOF == error ){\n        die(\"No integer passed: Die evil hacker!\\n\");\n    }\n    if ( m > MAX_DIM || n > MAX_DIM ) {\n        die(\"Value too large: Die evil hacker!\\n\");\n    }\n    board = (board_square_t*) malloc( m * n * sizeof(board_square_t));\n    return board;\n}"}
{"idx": 14, "msg": "Buffer overflow", "code": "int main(int argc, char **argv) {\n  volatile int modified;\n  char buffer[64];\n  modified = 0;\n  gets(buffer);\n  if(modified != 0) {\n    printf(\"you have changed the 'modified' variable\\n\");\n  } else {\n    printf(\"Try again?\\n\");\n  }\n}"}
{"idx": 15, "msg": "Dangling pointer", "code": "int foo(struc ptr*) {\n    free(ptr->member);\n    free(ptr->field);\n    return 0;\n}"}
{"idx": 16, "msg": "Dangling pointer", "code": "int main() {\n    int *ptr = (int *)malloc(sizeof(int));\n    *ptr = 20;\n    free(ptr); \n    printf(\"%d\\n\", *ptr);\n    return 0;\n}"}
{"idx": 17, "msg": "Dangling pointer", "code": "int *fun(){  \n    int y=10;  \n    return &y;  \n}  \nint main()  \n{  \n    int *p=fun();  \n    printf(\"%d\", *p);  \n    return 0;  \n}  "}
{"idx": 18, "msg": "Possible buffer overflow", "code": "int fun() {\n    nresp = packet_get_int();\n    if (nresp > 0) {\n    response = xmalloc(nresp*sizeof(char*));\n    for (i = 0; i < nresp; i++)\n        response[i] = packet_get_string(NULL);\n    }\n}"}
{"idx": 19, "msg": "Out of bounds read", "code": "int pure_memcmp(const void *const b1_, const void *const b2_, size_t len) {\n   const unsigned char *b1 = (const unsigned char *) b1_;\n   const unsigned char *b2 = (const unsigned char *) b2_;\n   size_t i;\n   unsigned char d = (unsigned char) 0 U;\n   for (i = 0 U; i < len; i++) {\n        d |= b1[i] ^ b2[i];\n   }\n   return (int)((1 &((d - 1) >> 8)) - 1);\n}\n\nint pure_strcmp(const char *const s1, const char *const s2) {\n    return pure_memcmp(s1, s2, strlen(s1) + 1 U);\n}"}
{"idx": 20, "msg": "Buffer overflow", "code": "int process_client() {\n    struct hostent *clienthp;\n    char hostname[MAX_LEN];\n\n    // accept client connections and process requests\n    int count = 0;\n    for (count = 0; count < MAX_CONNECTIONS; count++) {\n\n        int clientlen = sizeof(struct sockaddr_in);\n        int clientsocket = accept(serversocket, (struct sockaddr *)&clientaddr, &clientlen);\n\n        if (clientsocket >= 0) {\n            clienthp = gethostbyaddr((char*) &clientaddr.sin_addr.s_addr, sizeof(clientaddr.sin_addr.s_addr), AF_INET);\n            strcpy(hostname, clienthp->h_name);\n            logOutput(\"Accepted client connection from host \", hostname);\n            close(clientsocket);\n        }\n    }\n    close(serversocket);\n    return 0;\n}"}
{"idx": 21, "msg": "Possible buffer underwrite on whitespace input", "code": "char* trimTrailingWhitespace(char *strMessage, int length) {\n    char *retMessage;\n    char *message = malloc(sizeof(char)*(length+1));\n\n    // copy input string to a temporary string\n    char message[length+1];\n    int index;\n    for (index = 0; index < length; index++) {\n        message[index] = strMessage[index];\n    }\n    message[index] = '\\0';\n\n    // trim trailing whitespace\n    int len = index-1;\n    while (isspace(message[len])) {\n        message[len] = '\\0';\n        len--;\n    }\n\n    // return string without trailing whitespace\n    retMessage = message;\n    return retMessage;\n}"}
{"idx": 22, "msg": "Possible buffer underwrite if ch not found", "code": "int main() {\n    strncpy(destBuf, &srcBuf[find(srcBuf, ch)], 1024);\n}"}
{"idx": 23, "msg": "Incorrect pointer scaling", "code": "int *p = x;\nchar * second_char = (char *)(p + 1);"}
{"idx": 23, "msg": "Incorrect pointer scaling", "code": "int *p = x;\nchar * second_char = (char *)(p + 1);"}
{"idx": 24, "msg": "Bad pointer arithmetic", "code": "int size(struct node* head) {\n    struct node* current = head;\n    struct node* tail;\n    while (current != NULL) {\n        tail = current;\n        current = current->next;\n        }\n    return tail - head;\n}"}
{"idx": 25, "msg": "NULL dereference", "code": "void host_lookup(char *user_supplied_addr){\n    struct hostent *hp;\n    in_addr_t *addr;\n    char hostname[64];\n    in_addr_t inet_addr(const char *cp);\n\n    /*routine that ensures user_supplied_addr is in the right format for conversion */\n\n    validate_addr_form(user_supplied_addr);\n    addr = inet_addr(user_supplied_addr);\n    hp = gethostbyaddr( addr, sizeof(struct in_addr), AF_INET); // can return null\n    strcpy(hostname, hp->h_name);\n}"}
{"idx": 26, "msg": "Expired pointer reference", "code": "int foo(int SIZE) {\n    char* ptr = (char*)malloc (SIZE);\n    if (err) {\n        abrt = 1;\n        free(ptr);\n    }\n\n    // Some code here\n\n    if (abrt) {\n        logError(\"operation aborted before commit\", ptr);\n    }\n}"}
{"idx": 27, "msg": "Bad free", "code": "char **ap, *argv[10], *inputstring;\nfor (ap = argv; (*ap = strsep(&inputstring, \" \\t\")) != NULL;)\n    if (**ap != '\\0')\n        if (++ap >= &argv[10])\n            break;\n\nfree(ap[4]);"}
{"idx": 28, "msg": "Bad free", "code": "#define SUCCESS (1)\n#define FAILURE (0)\n\nint contains_char(char c){\n    char *str;\n    str = (char*)malloc(20*sizeof(char));\n    strcpy(str, \"Search Me!\");\n    while( *str != NULL){\n        if( *str == c ){\n            /* matched char, free string and return success */\n            free(str);\n            return SUCCESS;\n        }\n        /* didn't match yet, increment pointer and try next char */\n        str = str + 1;\n    }\n    /* we did not match the char in the string, free mem and return failure */\n\n    free(str);\n    return FAILURE;\n}"}
{"idx": 29, "msg": "Bad free", "code": "int foo() {\n    //hardcode input length for simplicity\n    char* input = (char*) malloc(40*sizeof(char));\n    char *tok;\n    char* sep = \" \\t\";\n\n    get_user_input( input );\n\n    /* The following loop will parse and process each token in the input string */\n\n    tok = strtok( input, sep);\n    while( NULL != tok ){\n        if( isMalformed( tok ) ){\n            /* ignore and discard bad data */\n            free( tok );\n        } else {\n            add_to_command_queue( tok );\n        }\n    tok = strtok( NULL, sep));\n    }\n    return 0;\n}"}
{"idx": 30, "msg": "Possible out of bounds", "code": "int main (int argc, char **argv) {\n    char *items[] = {\"boat\", \"car\", \"truck\", \"train\"};\n    int index = GetUntrustedOffset();\n    printf(\"You selected %s\\n\", items[index-1]);}"}